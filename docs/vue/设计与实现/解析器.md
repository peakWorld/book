# 解析器
解析器本质上是一个状态机。利用正则表达式来实现HTML解析器

## 文本模式及其对解析器的影响
* 文本模式: 解析器在工作时会进入的一些特殊状态(在不同的特殊状态下, 解析器对文本的解析行为会有所不同)
- 初始模式是 DATA
- 遇到<title>、<textarea>标签, 切换到 RCDATA模式
- 遇到<style>、<xmp>、<iframe>、<noframes>、<noscript>标签, 切换到 RAWTEXT模式
- 遇到<![CDATA[ 字符串, 切换到 CDATA模式

DATA    识别HTML实体、能解析标签
RCDATA  识别HTML实体、不能解析标签
RAWTEXT 解析所有字符并将它们设置为纯文本解析，而不是将它们解析为标记或实体。

> vuejs的模版DSL(一种专门为特定领域或特定业务需求而设计的计算机编程语言)中不允许出现<script>标签, 如果遇到也会切换到 RAWTEXT模式。

* 浏览器解析HTML规范
[WHATWG](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)
- HTML实体
特殊的字符序列(转义字符)，用于在HTML文档中表示不同类型的特殊字符。由“&”字符开头，以“;”字符结尾，会被转译为不同的字符.

- 标签
 - 自闭合标签
 - 完整标签: 由开始标签、子节点和结束标签 三部分构成。

## 递归下降算法构造模板 AST 16-1
创建Token与构建模板AST的过程可以同时进行(模板和模板AST具有同构的特性)

### parseChildren 函数
* 本质上是一个状态机, 状态机内有多少种状态取决于子节点的类型数量; 在模板中, 子节点
  - 标签节点 <div>
  - 文本插值节点 {{val}}
  - 普通文本节点 text
  - 注释节点 <!-- xx -->
  - CDATA节点 <![CDATA[ xxx ]]>
这里 `<!--` 和 `<![CDATA[` 当作一种标签; `{{` 当作一种实体; 然后实现WHATWG标准

while循环何时结束？parseChildren函数用来解析子节点, 在遇到父节点的结束标签才会结束。

```js
const template = `<div>
  <p>Text1</p>
  <p>Text2</p>
</div>`

// 在解析模板时, 不能忽略空白字符。包含 换行符(\n)、回车符(\r)、空格(' ')、制表符(\t)、换页符(\f)

// 如上模板用 加号(+)代表换行符、减号(-)代表空格字符
const template = `<div>+--<p>Text1</p>+--<p>Text2</p>+</div>`
```
解析过程:
开始解析 处于DATA模式。
解析器遇到的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 解析器进入标签节点状态, 并调用parseElement函数。[上述模板都是完整标签。]
- parseTag 解析开始标签。 包括开始标签上的属性和指令。执行完毕后, 会消费字符串中的内容`<div>`, 模板内容变为
> const template = `+--<p>Text1</p>+--<p>Text2</p>+</div>`
- 递归调用parseChildren函数解析子节点。 在parseTag解析完后, 生成一个标签节点element; 剩下的模板内容作为element的子节点被解析。在这个过程中会消费字符串 `+--<p>Text1</p>+--<p>Text2</p>+`, 模板内容变为
> const template = `</div>`
- parseEndTag 处理结束标签。

经过上述三个步骤后, 模板被解析完毕了; 但是在解析标签子节点时, 递归调用了parseChildren。这意味着一个新的状态机2开始运行了。
待处理模板: const template = `+--<p>Text1</p>+--<p>Text2</p>+`

开始解析
- 模板的第一个字符是换行符, 解析器进入文本节点状态, 并调用parseText完成文本节点解析(parseText将下一个`<`字符前的所有字符都视为文本节点的内容). 会消费字符串中的内容`+--`, 模板内容变为
> const template = `<p>Text1</p>+--<p>Text2</p>+`
parseText函数调用退出, 继续执行循环
- 此时模板的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 解析器再次进入 parseElement函数。会消费字符串中的内容`<p>Text1</p>`, 模板内容变为
> const template = `+--<p>Text2</p>+`
parseElement函数调用退出, 继续执行循环
- 第一个字符是换行符, 调用parseText完成文本节点解析. 会消费字符串中的内容`+--`, 模板内容变为
> const template = `<p>Text2</p>+`
- 此时模板的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 再次调用parseElement函数。消费字符串中的内容`<p>Text2</p>`, 模板内容变为
> const template = `+`
- 此时模板只剩一个换行符。继续执行循环, 调用parseText生成文本节点。

在状态机2运行期间, 又调用了2次parseElement; 而parseElement会调用parseChildren来处理子节点的解析, 意味着解析器会开启两个新的状态机。

上级parseChildren函数的调用用于构造上级模板AST节点, 被递归调用的下级parseChildren函数则用于构造下级模板AST节点; 最终构造出一棵树型结构的模板AST.

## 状态机的开启与停止 16-2
在调用parseElement函数解析标签节点时, 会调用parseChildren函数(开启新的状态机)

```js
const template = `<div>+--<p>Text1</p>+--<p>Text2</p>+</div>`
```

开始解析, 调用parseChildren函数
- 遇到`<div>`标签, 调用parseElement函数
- 解析开始标签, 将解析的标签节点压入ancestors中, 即 [div]
- 解析子节点, 调用parseChildren函数; 开启 '状态机1' `+--<p>Text1</p>+--<p>Text2</p>+</div>`
  - 遇到`<p>`标签, 调用parseElement函数 `<p>Text1</p>+--<p>Text2</p>+</div>`
    - 遇到开始标签、解析
    - 将解析得到的标签节点压入ancestors中, 即 [div, p]
    - 解析子节点
      - 调用parseChildren函数; 开启 '状态机2' 
      - 遇到`</p>`标签, '状态机2' 结束(isEnd函数返回true), 退出解析字节点的 parseChildren函数
    - 弹出ancestors中的同名标签, 即 [div] 
    - 解析结束标签
- 继续运行 ‘状态机1’ `+--<p>Text2</p>+</div>`
  - 遇到`<p>`标签, 调用parseElement函数 `<p>Text2</p>+</div>`
    - 遇到开始标签、解析
    - 将解析得到的标签节点压入ancestors中, 即 [div, p]
    - 解析子节点,
      - 调用parseChildren函数; 开启 '状态机3'
      - 遇到`</p>`标签, '状态机3' 结束 (isEnd函数返回true), 退出解析字节点的 parseChildren函数
    - 弹出ancestors中的同名标签, 即 [div]
    - 解析结束标签
- 继续运行 ‘状态机1’ `+</div>`
- 遇到`</div>`标签, '状态机1' 结束 (isEnd函数返回true), 退出解析字节点的 parseChildren函数
- 弹出ancestors中的同名标签, 即 [div]
- 解析结束标签
结束最外层的parseChildren函数调用

结论:
当解析器遇到开始标签时，会将该标签压入父级节点栈，同时开启新的状态机；
当解析器遇到结束标签，并且父级节点栈中存在与该标签同名的开始节点标签时，会停止当前正在运行的状态机。

在parseElement函数中解析标签元素, 生成解析子节点的‘状态机’
在isEnd函数, 根据结束标签判断当前循环是否结束, 结束‘状态机’

```jsx
// 解释一
function isEnd(context, ancestors) {
  // 停止时机1: 模板内容解析完
  if (!context.source) return true;
  const parent = ancestors[ancestors.length - 1]; // 父级标签节点
  // 停止时机2: 遇到结束标签, 且与父级标签节点同名
  if (parent && context.source.startWith(`</${parent.tag}`)) {
    return true;
  }
}
```

停止时机2 严格来说是有瑕疵的, 如 `<div><span></div></span>`

解释一：`</div>`为无效的结束标签

状态机1 遇到`<div>`, 调用parseElement函数, 开启 ‘状态机2’; [div]
状态机2 遇到`<span>`, 调用parseElement函数, 开启 ‘状态机3’; [div, span]
状态机3 却遇到了结束标签`</div>`; 由于此时父级节点为span并不是div，所以‘状态机3’不会停止运行；会进入parseChildren中结束标签的逻辑分支; 抛出错误 '无效的结束标签'。

解释二：`<div><span></div>` 为完整内容, `</span>`缺少闭合标签
此时 ’停止时机2‘ 不应该总是与栈顶的父级节点比较, 而是应该与整个栈中的所有节点做比较。

状态机1 遇到`<div>`, 调用parseElement函数, 开启 ‘状态机2’; [div]
状态机2 遇到`<span>`, 调用parseElement函数, 开启 ‘状态机3’; [div, span]
状态机3 遇到了结束标签`</div>`, 在栈中存在标签div; 结束‘状态机3’;

而‘状态机2’此时的标签为‘span’, 不是‘div’; 输出 span标签缺少闭合标签

## 解析标签节点 16-3
[]("./解析标签节点.jpeg")
- '<div>'  开始标签
- '</div>' 结束标签
- '<div---->' 带空格的开始标签(-代表空格)

## 解析属性 16-4
parseTag 解析函数在消费整个开始标签时, 需要处理标签中存在的属性与指令。
```ts
  <div id = "foo" v-show="display">
  // 消费标签的开始部分 与 无用空白字符

  // parseAttributes函数实际处理部分
  id = "foo" v-show="display">
```
<!-- 属性都有值 -->
- 解析出第一个属性的名称id, 并消费字符串'id' => ` = "foo" v-show="display">`
  - 属性名称和等于号之间可能存在空白字符
  - 在属性名称解析完毕后, 模板剩余内容一定是以等于号开头的
- 消费等于号  => `"foo" v-show="display">`
  - 等于号和属性值之间可能存在空白字符, 也必须消费掉
- 处理属性值(双引号、单引号、无引号)
  - 检查当前模板内容是否以引号开头来确定属性值。如果有则消费引号 => `foo" v-show="display">`
  - 属性值被引号引用, 则下一个引号之前的内容都应该解析为属性值, 此处属性值为字符串 foo
  - 消费属性值及其后引号 => `v-show="display">`
- 第一个属性处理完毕
  - 重复处理 'v-show' 指令 => `>`
  - 遇到字符>, 循环结束; 完成属性和指令的解析。

* /^[^\t\r\n\f />][^\t\r\n\f />=]*/
- `[^\t\r\n\f />]` 不能是空白字符、字符/ 或 字符>, 以该位置开头
- `[^\t\r\n\f />=]` 不能是空白字符、字符/、>、=
- 匹配等于号之前的内容, 即属性名

* /^[^\t\r\n\f >]+/
- 不能是空白字符 和 字符>
- 对字符进行匹配, 知道遇到 空白字符 或 字符> 为止

## 解析文本与解码HTML实体 16-5
* parseText
状态机始于 “状态1”, 如果读取模板的第一个字符T, 即不是字符`<`也不是插值定界符`{{`; 进入 “状态7”即调用parseText函数处理文本内容。
- 寻找下一个`<`字符或插值定界符`{{`的位置索引I, 从模板头部到索引I的位置截取内容将作为文本节点的内容。

### 解码命名字符引用
HTML实体是一段以字符&开始的文本内容。实体用来描述HTML中保留字符和一些难以通过普通键盘输入的字符，以及一些不可见的字符; 以字符`&`开始, 以字符`;`结尾.

例: 字符<具有特殊含义, 希望以普通文本的方式来显示字符<, 需要通过实体来表达 &lt; 直接使用将会产生非法的内容。

- 命名字符引用
命名实体, 有特定的名称。 例 &lt; => `<`

- 数字字符引用
没有特定的名称, 只能用数字表示。 例 &#60; &#x3c; => `<`
十进制 `&# + 数字` / 十六进制 `&#x + 数字`

在Vue模板中, 文本节点所包含的HTML实体不会被浏览器解析; 在模板中的文本节点最终通过el.textContent等文本操作设置到页面, 而el.textContent不会执行HTML实体解码。

```ts
// 页面呈现为'&lt', 而不是'<'
el.textContent = '&lt';
```
[实体解析]("./HTML实体解析.jpeg")
- 解析器遇到字符&时, 进入“字符引用状态”, 并消耗字符&;
- 下一个字符是 ASCII字母或数字, 进入“命名字符引用状态”, 0-9a-zA-Z;
- 如果下一个字符是 #, 进入 “数字字符引用状态”

* 命名字符引用
`a&ltb` => `a<b`
- 遇到&时, 进入“命名字符引用状态”。解析下一个字符l, 在‘引用表’中查找字符l开头的项, 匹配 存在 lt、lg等
- 解析下一个字符t, 在‘引用表’中查找lt开头的项, 匹配 存在 lt、ltcc等
- 解析下一个字符b, 在引用表’ 中未找到, 不匹配
- 匹配结束, 检查最后一个匹配的字符。如果字符是分号(;), 则产生一个合法的匹配, 并渲染对应字符; 而上例中匹配的最后一个字符是t, 并不是分号(;),  解析失败、但浏览器仍能解析, 此时遵循“最短原则”(命名字符引用的名称最短)
```ts
a&ltcc;  // a⪦
a&ltcc // a<cc   最短原则
```

* 用作属性值的文本
`<a href="foo.com?a=1&lt=2">foo.com?a=1&b=2</a>`
此处a标签的href属性值与它的文本节点具有同样的内容, 但解析之后的结果不同。
- 属性值中的&lt将原封不动展示
- 文本节点中的&lt将会解析为字符<

* 当存在分号时: 执行完整匹配; 当省略分号时: 执行最短匹配。
`a&ltccbbb` => `a<ccbbb`

- 普通文本: a
- 另外部分: &ltccbbb
  - 第一步: 计算出命名字符引用表中实体名称的最大长度。在namedCharacterReference中最长实体为`ltcc;`,长度为5
  - 第二步: 根据最大长度截取字符串ltccbbb, 即 `'ltccbbb'.slice(0, 5)` 为 'ltccb'
  - 第三步: 用截取后的字符串'ltccb'作为键去命名字符引用表中查询对应的值; 而namedCharacterReference中不存在该键, 不匹配
  - 第四步: 发现不匹配, 将最大长度减1, 重新执行第二步, 直到找到匹配项为止。最终匹配为‘lt’.

### 解码数字字符引用
[]('./数字引用字符1.jpeg')
[]('./数字引用字符2.jpeg')

## 解析插值与注释
* 解析插值 将文本插值的开始定界符与结束定界符之间的内容提取出来
