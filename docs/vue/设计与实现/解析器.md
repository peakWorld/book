# 解析器
解析器本质上是一个状态机。利用正则表达式来实现HTML解析器

## 文本模式及其对解析器的影响
* 文本模式: 解析器在工作时会进入的一些特殊状态(在不同的特殊状态下, 解析器对文本的解析行为会有所不同)
- 初始模式是 DATA
- 遇到<title>、<textarea>标签, 切换到 RCDATA模式
- 遇到<style>、<xmp>、<iframe>、<noframes>、<noscript>标签, 切换到 RAWTEXT模式
- 遇到<![CDATA[ 字符串, 切换到 CDATA模式

DATA    识别HTML实体、能解析标签
RCDATA  识别HTML实体、不能解析标签
RAWTEXT 解析所有字符并将它们设置为纯文本解析，而不是将它们解析为标记或实体。

> vuejs的模版DSL(一种专门为特定领域或特定业务需求而设计的计算机编程语言)中不允许出现<script>标签, 如果遇到也会切换到 RAWTEXT模式。

* 浏览器解析HTML规范
[WHATWG](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)
- HTML实体
特殊的字符序列(转义字符)，用于在HTML文档中表示不同类型的特殊字符。由“&”字符开头，以“;”字符结尾，会被转译为不同的字符.

- 标签
 - 自闭合标签
 - 完整标签: 由开始标签、子节点和结束标签 三部分构成。

## 递归下降算法构造模板 AST 16-1
创建Token与构建模板AST的过程可以同时进行(模板和模板AST具有同构的特性)

### parseChildren 函数
* 本质上是一个状态机, 状态机内有多少种状态取决于子节点的类型数量; 在模板中, 子节点
  - 标签节点 <div>
  - 文本插值节点 {{val}}
  - 普通文本节点 text
  - 注释节点 <!-- xx -->
  - CDATA节点 <![CDATA[ xxx ]]>
这里 `<!--` 和 `<![CDATA[` 当作一种标签; `{{` 当作一种实体; 然后实现WHATWG标准

while循环何时结束？parseChildren函数用来解析子节点, 在遇到父节点的结束标签才会结束。

```js
const template = `<div>
  <p>Text1</p>
  <p>Text2</p>
</div>`

// 在解析模板时, 不能忽略空白字符。包含 换行符(\n)、回车符(\r)、空格(' ')、制表符(\t)、换页符(\f)

// 如上模板用 加号(+)代表换行符、减号(-)代表空格字符
const template = `<div>+--<p>Text1</p>+--<p>Text2</p>+</div>`
```
解析过程:
开始解析 处于DATA模式。
解析器遇到的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 解析器进入标签节点状态, 并调用parseElement函数。[上述模板都是完整标签。]
- parseTag 解析开始标签。 包括开始标签上的属性和指令。执行完毕后, 会消费字符串中的内容`<div>`, 模板内容变为
> const template = `+--<p>Text1</p>+--<p>Text2</p>+</div>`
- 递归调用parseChildren函数解析子节点。 在parseTag解析完后, 生成一个标签节点element; 剩下的模板内容作为element的子节点被解析。在这个过程中会消费字符串 `+--<p>Text1</p>+--<p>Text2</p>+`, 模板内容变为
> const template = `</div>`
- parseEndTag 处理结束标签。

经过上述三个步骤后, 模板被解析完毕了; 但是在解析标签子节点时, 递归调用了parseChildren。这意味着一个新的状态机2开始运行了。
待处理模板: const template = `+--<p>Text1</p>+--<p>Text2</p>+`

开始解析
- 模板的第一个字符是换行符, 解析器进入文本节点状态, 并调用parseText完成文本节点解析(parseText将下一个`<`字符前的所有字符都视为文本节点的内容). 会消费字符串中的内容`+--`, 模板内容变为
> const template = `<p>Text1</p>+--<p>Text2</p>+`
parseText函数调用退出, 继续执行循环
- 此时模板的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 解析器再次进入 parseElement函数。会消费字符串中的内容`<p>Text1</p>`, 模板内容变为
> const template = `+--<p>Text2</p>+`
parseElement函数调用退出, 继续执行循环
- 第一个字符是换行符, 调用parseText完成文本节点解析. 会消费字符串中的内容`+--`, 模板内容变为
> const template = `<p>Text2</p>+`
- 此时模板的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 再次调用parseElement函数。消费字符串中的内容`<p>Text2</p>`, 模板内容变为
> const template = `+`
- 此时模板只剩一个换行符。继续执行循环, 调用parseText生成文本节点。

在状态机2运行期间, 又调用了2次parseElement; 而parseElement会调用parseChildren来处理子节点的解析, 意味着解析器会开启两个新的状态机。

上级parseChildren函数的调用用于构造上级模板AST节点, 被递归调用的下级parseChildren函数则用于构造下级模板AST节点; 最终构造出一棵树型结构的模板AST.

## 状态机的开启与停止 16-2
在调用parseElement函数解析标签节点时, 会调用parseChildren函数(开启新的状态机)

```js
const template = `<div>+--<p>Text1</p>+--<p>Text2</p>+</div>`
```

开始解析, 调用parseChildren函数
- 遇到`<div>`标签, 调用parseElement函数
- 解析开始标签, 将解析的标签节点压入ancestors中, 即 [div]
- 解析子节点, 调用parseChildren函数; 开启 '状态机1' `+--<p>Text1</p>+--<p>Text2</p>+</div>`
  - 遇到`<p>`标签, 调用parseElement函数 `<p>Text1</p>+--<p>Text2</p>+</div>`
    - 遇到开始标签、解析
    - 将解析得到的标签节点压入ancestors中, 即 [div, p]
    - 解析子节点
      - 调用parseChildren函数; 开启 '状态机2' 
      - 遇到`</p>`标签, '状态机2' 结束(isEnd函数返回true), 退出解析字节点的 parseChildren函数
    - 弹出ancestors中的同名标签, 即 [div] 
    - 解析结束标签
- 继续运行 ‘状态机1’ `+--<p>Text2</p>+</div>`
  - 遇到`<p>`标签, 调用parseElement函数 `<p>Text2</p>+</div>`
    - 遇到开始标签、解析
    - 将解析得到的标签节点压入ancestors中, 即 [div, p]
    - 解析子节点,
      - 调用parseChildren函数; 开启 '状态机3'
      - 遇到`</p>`标签, '状态机3' 结束 (isEnd函数返回true), 退出解析字节点的 parseChildren函数
    - 弹出ancestors中的同名标签, 即 [div]
    - 解析结束标签
- 继续运行 ‘状态机1’ `+</div>`
- 遇到`</div>`标签, '状态机1' 结束 (isEnd函数返回true), 退出解析字节点的 parseChildren函数
- 弹出ancestors中的同名标签, 即 [div]
- 解析结束标签
结束最外层的parseChildren函数调用

结论:
当解析器遇到开始标签时，会将该标签压入父级节点栈，同时开启新的状态机；
当解析器遇到结束标签，并且父级节点栈中存在与该标签同名的开始节点标签时，会停止当前正在运行的状态机。

在parseElement函数中解析标签元素, 生成解析子节点的‘状态机’
在isEnd函数, 根据结束标签判断当前循环是否结束, 结束‘状态机’

```jsx
// 解释一
function isEnd(context, ancestors) {
  // 停止时机1: 模板内容解析完
  if (!context.source) return true;
  const parent = ancestors[ancestors.length - 1]; // 父级标签节点
  // 停止时机2: 遇到结束标签, 且与父级标签节点同名
  if (parent && context.source.startWith(`</${parent.tag}`)) {
    return true;
  }
}
```

停止时机2 严格来说是有瑕疵的, 如 `<div><span></div></span>`

解释一：`</div>`为无效的结束标签

状态机1 遇到`<div>`, 调用parseElement函数, 开启 ‘状态机2’; [div]
状态机2 遇到`<span>`, 调用parseElement函数, 开启 ‘状态机3’; [div, span]
状态机3 却遇到了结束标签`</div>`; 由于此时父级节点为span并不是div，所以‘状态机3’不会停止运行；会进入parseChildren中结束标签的逻辑分支; 抛出错误 '无效的结束标签'。

解释二：`<div><span></div>` 为完整内容, `</span>`缺少闭合标签
此时 ’停止时机2‘ 不应该总是与栈顶的父级节点比较, 而是应该与整个栈中的所有节点做比较。

状态机1 遇到`<div>`, 调用parseElement函数, 开启 ‘状态机2’; [div]
状态机2 遇到`<span>`, 调用parseElement函数, 开启 ‘状态机3’; [div, span]
状态机3 遇到了结束标签`</div>`, 在栈中存在标签div; 结束‘状态机3’;

而‘状态机2’此时的标签为‘span’, 不是‘div’; 输出 span标签缺少闭合标签

## 解析标签节点 16-3
[]("./解析标签节点.jpeg")
- '<div>'  开始标签
- '</div>' 结束标签
- '<div---->' 带空格的开始标签(-代表空格)

## 解析属性 16-4
parseTag 解析函数在消费整个开始标签时, 需要处理标签中存在的属性与指令。
```ts
  <div id = "foo" v-show="display">
  // 消费标签的开始部分 与 无用空白字符

  // parseAttributes函数实际处理部分
  id = "foo" v-show="display">
```
<!-- 属性都有值 -->
- 解析出第一个属性的名称id, 并消费字符串'id' => ` = "foo" v-show="display">`
  - 属性名称和等于号之间可能存在空白字符
  - 在属性名称解析完毕后, 模板剩余内容一定是以等于号开头的
- 消费等于号  => `"foo" v-show="display">`
  - 等于号和属性值之间可能存在空白字符, 也必须消费掉
- 处理属性值(双引号、单引号、无引号)
  - 检查当前模板内容是否以引号开头来确定属性值。如果有则消费引号 => `foo" v-show="display">`
  - 属性值被引号引用, 则下一个引号之前的内容都应该解析为属性值, 此处属性值为字符串 foo
  - 消费属性值及其后引号 => `v-show="display">`
- 第一个属性处理完毕

