# 解析器
解析器本质上是一个状态机。利用正则表达式来实现HTML解析器

## 文本模式及其对解析器的影响
* 文本模式: 解析器在工作时会进入的一些特殊状态(在不同的特殊状态下, 解析器对文本的解析行为会有所不同)
- 初始模式是 DATA
- 遇到<title>、<textarea>标签, 切换到 RCDATA模式
- 遇到<style>、<xmp>、<iframe>、<noframes>、<noscript>标签, 切换到 RAWTEXT模式
- 遇到<![CDATA[ 字符串, 切换到 CDATA模式

DATA    识别HTML实体、能解析标签
RCDATA  识别HTML实体、不能解析标签
RAWTEXT 解析所有字符并将它们设置为纯文本解析，而不是将它们解析为标记或实体。

> vuejs的模版DSL(一种专门为特定领域或特定业务需求而设计的计算机编程语言)中不允许出现<script>标签, 如果遇到也会切换到 RAWTEXT模式。

* 浏览器解析HTML规范
[WHATWG](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)
- HTML实体
特殊的字符序列(转义字符)，用于在HTML文档中表示不同类型的特殊字符。由“&”字符开头，以“;”字符结尾，会被转译为不同的字符.

- 标签
 - 自闭合标签
 - 完整标签: 由开始标签、子节点和结束标签 三部分构成。

## 递归下降算法构造模板 AST 16-1
创建Token与构建模板AST的过程可以同时进行(模板和模板AST具有同构的特性)

### parseChildren 函数
* 本质上是一个状态机, 状态机内有多少种状态取决于子节点的类型数量; 在模板中, 子节点
  - 标签节点 <div>
  - 文本插值节点 {{val}}
  - 普通文本节点 text
  - 注释节点 <!-- xx -->
  - CDATA节点 <![CDATA[ xxx ]]>
这里 `<!--` 和 `<![CDATA[` 当作一种标签; `{{` 当作一种实体; 然后实现WHATWG标准

while循环何时结束？parseChildren函数用来解析子节点, 在遇到父节点的结束标签才会结束。

```js
const template = `<div>
  <p>Text1</p>
  <p>Text2</p>
</div>`

// 在解析模板时, 不能忽略空白字符。包含 换行符(\n)、回车符(\r)、空格(' ')、制表符(\t)、换页符(\f)

// 如上模板用 加号(+)代表换行符、减号(-)代表空格字符
const template = `<div>+--<p>Text1</p>+--<p>Text2</p>+</div>`
```
解析过程:
开始解析 处于DATA模式。
解析器遇到的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 解析器进入标签节点状态, 并调用parseElement函数。[上述模板都是完整标签。]
- parseTag 解析开始标签。 包括开始标签上的属性和指令。执行完毕后, 会消费字符串中的内容`<div>`, 模板内容变为
> const template = `+--<p>Text1</p>+--<p>Text2</p>+</div>`
- 递归调用parseChildren函数解析子节点。 在parseTag解析完后, 生成一个标签节点element; 剩下的模板内容作为element的子节点被解析。在这个过程中会消费字符串 `+--<p>Text1</p>+--<p>Text2</p>+`, 模板内容变为
> const template = `</div>`
- parseEndTag 处理结束标签。

经过上述三个步骤后, 模板被解析完毕了; 但是在解析标签子节点时, 递归调用了parseChildren。这意味着一个新的状态机2开始运行了。
待处理模板: const template = `+--<p>Text1</p>+--<p>Text2</p>+`

开始解析
- 模板的第一个字符是换行符, 解析器进入文本节点状态, 并调用parseText完成文本节点解析(parseText将下一个`<`字符前的所有字符都视为文本节点的内容). 会消费字符串中的内容`+--`, 模板内容变为
> const template = `<p>Text1</p>+--<p>Text2</p>+`
parseText函数调用退出, 继续执行循环
- 此时模板的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 解析器再次进入 parseElement函数。会消费字符串中的内容`<p>Text1</p>`, 模板内容变为
> const template = `+--<p>Text2</p>+`
parseElement函数调用退出, 继续执行循环
- 第一个字符是换行符, 调用parseText完成文本节点解析. 会消费字符串中的内容`+--`, 模板内容变为
> const template = `<p>Text2</p>+`
- 此时模板的第一个字符为`<`, 并且第二个字符匹配表达式/a-z/i; 再次调用parseElement函数。消费字符串中的内容`<p>Text2</p>`, 模板内容变为
> const template = `+`
- 此时模板只剩一个换行符。继续执行循环, 调用parseText生成文本节点。

在状态机2运行期间, 又调用了2次parseElement; 而parseElement会调用parseChildren来处理子节点的解析, 意味着解析器会开启两个新的状态机。

上级parseChildren函数的调用用于构造上级模板AST节点, 被递归调用的下级parseChildren函数则用于构造下级模板AST节点; 最终构造出一棵树型结构的模板AST.

## 状态机的开启与停止 16-2
在调用parseElement函数解析标签节点时, 会调用parseChildren函数(开启新的状态机)

```js
const template = `<div>+--<p>Text1</p>+--<p>Text2</p>+</div>`
```

开始解析, 调用parseChildren函数
- 遇到`<div>`标签, 调用parseElement函数
- 解析开始标签, 将解析的标签节点压入ancestors中, 即 [div]
- 解析子节点, 调用parseChildren函数; 开启 '状态机1' `+--<p>Text1</p>+--<p>Text2</p>+</div>`
  - 遇到`<p>`标签, 调用parseElement函数 `<p>Text1</p>+--<p>Text2</p>+</div>`
    - 解析开始标签
    - 将解析得到的标签节点压入ancestors中, 即 [div, p]
    - 解析子节点
      - 调用parseChildren函数; 开启 '状态机2' 
      - 遇到`</p>`标签, '状态机2' 结束
    - 弹出ancestors中的同名标签, 即 [div] 
    - 解析结束标签
- 继续运行 ‘状态机1’ `+--<p>Text2</p>+</div>`
  - 遇到`<p>`标签, 调用parseElement函数 `<p>Text2</p>+</div>`
    - 解析开始标签
    - 将解析得到的标签节点压入ancestors中, 即 [div, p]
    - 解析子节点,
      - 调用parseChildren函数; 开启 '状态机3'
      - 遇到`</p>`标签, '状态机3' 结束
    - 弹出ancestors中的同名标签, 即 [div]
    - 解析结束标签
- 继续运行 ‘状态机1’ `+</div>`
- 遇到`</div>`标签, '状态机1' 结束  => 此时只是结束了循环, 但是结束标签还未解析
- 弹出ancestors中的同名标签, 即 [div]
- 解析结束标签
结束最外层的parseChildren函数调用