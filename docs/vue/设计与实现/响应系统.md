# 响应系统的作用与实现

## 响应式数据和副作用函数
* 副作用函数: 会产生副作用的函数, 函数的执行会直接或间接影响其他函数的执行。
* 响应式数据: 值变化后, 副作用函数自动重新执行。

## 响应式数据的实现
* 拦截对象的读取和设置操作
  * 读取操作时将副作用函数存在一个‘桶’中
  * 设置操作时将副作用函数从‘桶’中取出并执行
* 数据结构
  * WeakMap 由 target(对象) --> Map构成
  * Map     由 key(属性) --> Set构成, 其内为副作用函数
* 分支切换
```js
  // case2中执行, 有遗留的副作用函数
  // 在case3中修正
  effect(() => {
    document.body.innerText = obj.ok ? obj.text : 'not'
  })

  // obj.ok 为 true
  // ‘桶’ 中添加 ‘ok’、‘text’ 副作用函数

  // obj.ok = false
  // 只执行 ‘ok’ 副作用函数

  // obj.text = ‘abc’
  // 执行 ‘text’ 副作用函数, 但是 body 的文本不会变
```
* 嵌套
```js
  // case3中执行, 输出不符合要求
  let temp1, temp2
  effect(function effectFn1() {
    console.log('effectFn1 执行')
    effect(function effectFn2() {
      console.log('effectFn2 执行')
      temp2 = obj.bar
    })
    temp1 = obj.foo
  })
  obj.foo = false

  // effectFn1 执行 初始化
  // effectFn2 执行 初始化
  // effectFn2 执行 修改obj.foo值,输出不符合要求

  // 无限递归循环
  effect(() => {
    // obj.foo++
    // 既有读取操作, 又有设置操作
    obj.foo = obj.foo + 1
  })

  // 执行读取操作, 副作用函数进入桶中
  // 设置操作, forEach循环, 执行副作用函数
  // 读取、设置操作, 无法中止, 导致栈溢出
```
* 调度执行
当trigger动作触发副作用函数重新执行时, 有能力决定副作用函数执行的时机、次数以及方式。
```js
// 宏任务中设置标志, 微任务执行完后重置标志
```