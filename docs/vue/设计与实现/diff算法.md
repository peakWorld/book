# 简单Diff算法 9-4
比较两组子节点, 以最小的性能开销完成更新操作.
* 拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点, 记录该节点的索引为最大索引; 在更新过程中节点的索引小于最大索引, 则该节点对应的真实DOM元素需要移动。
* 利用虚拟节点的key属性, 尽可能地复用DOM元素，并通过移动DOM的方式来完成更新, 从而减少不断地创建和销毁DOM元素带来的性能开销。

## 减少DOM操作的性能开销 9-1
* 相同数量子节点 - 删除DOM操作取消
* 不同数量子节点 - 只进行必要的DOM操作

## DOM复用与key的作用
* 新旧两组子节点中的确存在可复用的节点。
* 只要两个虚拟节点的type属性值和key属性值都相同, 则认为他们是相同的。

## 找到需要移动的元素 9-2
通过key值找到可复用的节点, 思考节点是否需要移动、如何移动？
* 每次寻找可复用的节点时, 都会记录该复用节点在旧的一组子节点中的位置索引。
* 在旧children中寻找具有相同key值节点的过程中, 缓存遇到的最大索引值A。如果后续寻找的过程中, 存在索引值比A还小的节点, 则意味着该节点需要移动。

## 如何移动元素
移动一个节点所对应的真实DOM节点, 并不是移动虚拟节点本身。
* 新children的顺序其实就是更新后真实DOM节点应有的顺序。
* 真实DOM顺序与新的一组子节点的顺序相同。

## 添加新元素 9-3
* 找到新增节点、将新增节点挂载到正确位置

## 移除不存在的元素

# 双端Diff算法 10-1
* 简单diff算法对DOM的移动并不是最优的。
```js
// oldChildren
[
  { type: 'p', children: '1', key: 1 },
  { type: 'p', children: '2', key: 2 },
  { type: 'p', children: '3', key: 3 },
];

// newChildren
[
  { type: 'p', children: 'text 3', key: 3 },
  { type: 'p', children: 'text 1', key: 1 },
  { type: 'p', children: 'text 2', key: 2 },
];

// 简单diff, 需要将p-1、p-2移动到p-3之后, 要移动两次DOM。
// 但其实只要将p-3移动到p-1前也满足要求, 且只要移动一次。双端diff
```
* 一种同时对新旧两组子节点的两个端点进行比较的算法。

## 原理
![](./WechatIMG28.jpeg)
newChildren表示节点新的排列顺序; 其实移动的是oldChildren对应的DOM

## 双端比较的优势

## 非理想的处理方式 10-2
双端diff算法的每一轮比较都分为四个步骤, 在一轮比较不一定会命中四个步骤中某个。

## 添加新元素

# 快速Diff算法 11-1

## 相同的前置元素和后置元素
处理完相同的前后置节点后, 新旧两组子节点会有一组子节点被处理完毕。

## 判断是否需要进行DOM移动操作 11-2
处理完相同的前后置节点后, 新旧两组子节点都有剩余节点。
* diff算法的处理规则
  * 判断是否有节点需要移动, 以及应该如何移动。
  * 找出那些需要被添加或移除的节点。

## 如何移动元素 11-3
* 判断是否需要进行DOM操作
* 构建source数组, 计算一个最长递增子序列用于DOM移动操作。

