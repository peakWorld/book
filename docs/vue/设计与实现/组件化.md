# 组件的实现原理
渲染器主要负责将虚拟DOM渲染为真实的DOM, 但是页面复杂时用于描述的虚拟DOM代码量会变的多。此时需要组件化能力, 将一个大页面拆分为多个部分。

## 渲染组件

* 设计组件在用户层面的接口 12-1
- 如何编写组件？
- 组件的选项对象必须包含哪些内容？
- 组件拥有哪些能力？

组件是对内容的封装, 用来描述页面内容的一部分。

## 组件状态和自更新 12-2

## 组件实例与组件的生命周期

## props与组件的被动更新 12-3
```jsx
// 模板
<MyComponent title="A Big Title" :other="val" />

// 虚拟DOM
const vnode = {
  type: MyComponent,
  props: {
    title: 'A Big Title',
    other: this.val
  }
}

// 组件, 显式指定组件可接受的props数据
const MyComponent = {
  name: 'MyComponent',
  props: {
    title: String // 组件接受类型为String的title属性
  },
  render() {
    return {
      type: 'div',
      children: `count is: ${this.title}`
    }
  }
}
```
* props数据变化
MyComponent组件的props属性title发生了改变, 会使父组件自更新。然后调用patchCompont函数完成子组件的更新。
子组件被动更新: 由父组件自更新引起的子组件更新。
- 检测子组件是否真需要更新, props是否发生改变。
- 需要更新, 则更新子组件的props、slots等内容。

