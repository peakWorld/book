实现响应式数据要考虑的内容。

访问器属性'getter'导致的问题, 解决问题, 引出Reflect。

详细介绍Proxy 和 Reflect

proxy 创建一个代理对象, 实现对其他对象的代理; 无法代理非对象值. 
那么代理是什么？对一个对象`基本语义`的代理; 即允许`拦截`并`重新定义`对一个对象的基本操作。

‘基本语义’其实就是基本语义操作, 例如 对象的读取、设置操作; 但是有许多操作并非基本操作, 比如对象函数调用, 复合操作。

‘拦截并重新定义基本操作’
proxy = Proxy(data, { set() {} }) 
  如果没有tap-set, proxy调用自身的内部方法, 按ecma规范进行操作。
  但是有了tap-set, 就对内部方法[[Set]]进行了拦截, 且自定义了该内部方法, 
  即set这个基本操作的内部实现被重新定义了。
注意: 自定义的是 代理对象本身的内部方法和行为, 而不是原始数据的内部方法和行为。

表格 
内部方法、proxy拦截函数、Reflect对应函数 对应方法。
注： 内部方法 => 对一个对象进行操作时在引擎内部调用的方法, 对于js开发者不可见。

代理对象, 三种读取操作

合理触发响应

浅响应与深响应

额外
异质对象、常规对象。