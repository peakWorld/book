# V8下的垃圾回收机制
* 由于js的单线程机制, 垃圾回收过程会阻碍主线程逻辑的执行。
  * worker线程,负责计算密集型或高延迟的任务,不会影响主线程

## 回收策略
主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。

### 新生代内存
* 主要用于存放存活时间较短的对象
* Scavenge算法(一种典型的牺牲空间换取时间的算法)
  * 将新生代内存一分为二: 处于激活状态的区域称为From空间,未激活的区域称为To空间。
  * 垃圾回收时,将from空间中的存活对象复制到to空间中,然后清空from空间(即非存活的对象被自动回收), 完成复制后交换from和to空间
* `何时启动新生代内存GC？`
  * 当from空间内存不足时
* 晋升
  * 再次进行垃圾回收时,对from空间中的存活对象进行判断;如果 对象经历过一次Scavenge算法 或 to空间使用率大于25%, 该对象将转移到老生代中，不会再被复制到To空间

### 老生代内存
* 管理大量存活对象
* 算法 Mark-Sweep(标记清除)和 Mark-Compact(标记整理)
  * Mark-Sweep(标记清除)
    * 分为标记和清除两个阶段. 标记阶段会遍历堆中的所有对象,然后标记活着的对象; 清除阶段会将死亡的对象进行清除。
    * 步骤
      1. 垃圾回收器中构建一个根列表, 维护所有根节点。例如js中window对象就是一个根节点。
      2. 垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的。
      3. 垃圾回收器将会释放所有非活动的内存块。
    > 根节点 全局对象、本地函数的局部变量和参数、当前嵌套调用链上的其他函数的变量和参数
    * 经过Mark-Sweep, 内存空间可能会出现不连续的状态. 
      * 如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收, 但该次垃圾回收没有必要; 此时有大量空闲内存，只不过不连续.
  * Mark-Compact(标记整理)
    * 用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存
* `何时启动老生代内存GC？`
  * 空间内存不足
  * 空间中对象超过一定限制
  * 不能保证新生代中对象移动到老生代中
* 由于js是单线程, 标记阶段需要遍历所有的对象, 导致主线程任务暂停, 待执行完垃圾回收后才会再次恢复执行主任务的逻辑.
  * 减少垃圾回收带来的停顿时间，引入了Incremental Marking(增量标记)
  * 延迟清理(lazy sweeping) 和 增量式整理(incremental compaction)

## 内存泄漏
* 不再用到的内存，没有及时释放。例如: 循环引用
* 减少内存泄露
  * 尽可能少地创建全局变量
  * 手动清除定时器
  * 少用闭包
  * 清除DOM引用
  * 弱引用(weakMap和weakSet)


`GC原理、GC时机、GC带来的问题`