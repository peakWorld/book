# 事件机制

## 事件触发三个阶段
```js
// 捕获 window->document->html->body
// 目标阶段
// 冒牌 body->html->document->window
```

## 自定义事件
```js
// Event创建事件
const eDom = document.getElementById('event')
const event = new Event('event');
eDom.addEventListener('event', () => {
  console.log('event')
}, false);
eDom.onclick = () => eDom.dispatchEvent(event)

// CustomEvent ,添加额外参数必须是detail
const ceDom = document.getElementById('customEvent')
const customEvent = new CustomEvent('customEvent', { detail: { x: 1 } });
ceDom.addEventListener('customEvent', (e) => {
  console.log('customEvent')
  console.log(e.detail.x)
}, false);
ceDom.onclick = () => ceDom.dispatchEvent(customEvent)
```

# 跨域
* 同源策略: 协议、域名、端口 必须一致
* 跨域是为了阻止用户读取另一个域名下的内容; 一个源的脚本无法操作另一个源的资源。

## JSONP
* 利用javascript标签没有跨域限制, 但只限于Get请求
```js
// 客户端
function jsonp (url, cb) {
  const cb_name = 'jsonp_cb_' + Date.now()
  const path = `${url}&cb=${cb_name}`
  const script = document.createElement('script')
  script.src = src
  script.async = true
  document.head.appendChild(script)
  window[cb_name] = (res) => cb(res)
  script.onload = () => document.head.removeChild(script)
}

// 服务端, 设置返回类型为js文件
ctx.res.setHeader('Content-Type', 'text/javascript')
```

## CORS
* 简单请求
  * 请求方法: HEAD、GET、POST
  * 请求头信息: Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)
* 复杂请求(不满足简单请求要求的都是复杂请求)
  * 在正式请求前有一次预请求
* 配置
```js
  // 响应头
  // Access-Control-Allow-Origin 设定浏览器支持跨越的域名
  // Access-Control-Allow-Credentials
  // Access-Control-Expose-Headers 允许浏览器额外获取的头信息

  // 1. 同源请求(默认携带cookie信息)
  // 2. 跨域请求(默认不携带cookie信息)
    // 此时服务端设置响应头 Access-Control-Allow-Origin: *或具体的origin值
  // 3. 跨域请求 要携带cookie信息
    // 客户端设置: credentials: 'include'
    // 服务端设置: Access-Control-Allow-Origin: 具体的origin值,不能为*; Access-Control-Allow-Credentials: true
    // cookie遵循同源策略, 请求只会携带该域名下的cookie信息
  // 4. 跨域请求中, 会在请求头中自动添加origin字段(当前域名)
```

## 页面跨域
* 二级域名相同情况下, document.domain设置为同一个二级域名
```js
// document.domain 值是当前域名
// https://www.baidu.com https://news.baidu.com
  // 一级域名(顶级域名)com; 二级域名 baidu
// 在两个页面都设置 document.domain = "baidu.com", 则这两个页面就可以互相操作了
```
* hash/postMessage
```js
  // 一般用于 window.open 或 iframe 
  // 场景: A页面通过iframe加载非同源的页面B
  // 1. A无法通过 iframeDom.contentWindow.document来操作B页面
  // 如果A和B页面的二级域相同, 可以设置 document.domain 来实现页面元素操作
  // 2. A 和 B 实现 信息传递
  // 方法一:
  // A页面中 iframeDom.src = src + # + hash; 修改hash的值
  // B页面中 window.onhashchange = () => { window.location.hash }; 监听hash的改变
  // 方法二:
  // A页面中 iframe.contentWindow.postMessage(msg,url | *)
  // B页面中 window.addEventListener('message',function(e){ e.data }, false)
```

# 存储方式
* localStorage、sessionStorage、cookie、indexedDB、service worker
  
## localStorage
* 持久化存储数据、遵循同源策略

## sessionStorage
* 持久化存储数据、遵循同源策略且必须处于同一标签页
```js
// 浏览器标签A大开网页www.baidu.com, 设置了sessionStorage, 其他标签页(即使打开的也是www.baidu.com这个网址也不行)都不能访问标签A中设置的sessionStorage,但是刷新标签A,sessionStorage依旧存在,只有关闭该标签页,才会消失
```

## cookie
* 
* 同源请求自动携带, 跨域必须设置相关配置(见跨域CORS部分)
* 设置cookie, 必须在响应头中加上Set-Cookie字段`Set-Cookie: <cookie-name>=<cookie-value>;Domain=<domain-values>;Secure;HttpOnly`
* 网页获取或修改cookie
```js
document.cookie // 读取当前网页的所有cookie
document.cookie = 'key=value' // 写入一个cookie值
// 设置cookie
  document.cookie = 'a=22;expires=Thu, 09 Aug 2018 10:52:22 GMT;path=/;domain=.baidu.com'
// 更新cookie
  document.cookie = 'a=22;expires=Thu, 09 Aug 2018 10:52:22 GMT;path=/;' // 设置一个新的cookie(因为属性少一个domain属性, 改操作是给当前页面访问域名设置cookie)
  document.cookie = 'a=24;expires=Thu, 09 Aug 2018 10:52:22 GMT;path=/;domain=.baidu.com' // 成功更新cookie
// 删除cookie
  document.cookie = 'a=;expires=Thu, 01-Jan-1970 00:00:01 GMT;path=/;domain=.baidu.com' // cookie值设空,且设置一个过去的时间
```
* 属性
  * Expires  设置cookie的过期时间,到了指定时间后,浏览器不再保留这个cookie; 值是一个UTC格式
  * Max-Age  指从现在开始cookie存在的秒数,,到了指定时间后,浏览器不再保留这个cookie;(Max-Age 优先于 Expires, cookie未设置Expires或Max-Age,那么浏览器关闭,该cookie会被删除)
  * Domain   指定了请求时,那些域名要附加这个cookie。如果响应头Set-Cookie中没有设置Domain属性,浏览器会默认其设为当前域名
  * Path     指定了请求时,那些路径需要携带这个cookie。path = '/' 那么 请求路径 '/xxx' 都要携带这个cookie 
  * HttpOnly 表示该cookie只能在浏览器发出http请求时,才带上cookie;而ajax,document.cookie都不能获取该值
  * Secure   表示cookie只能在浏览器发出https请求时,才带上
  * SameSite 有3种类型
    * None 表示cookie在同站请求、跨站请求下都会发送
    * Strict 表示cookie在跨站请求时不会被发送, 只有同站请求才会发送
    * Lax 与Strict相同, 但用户从外部站点导航至URL时除外
  
## indexedDB(无限)
* [参考文献1](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API)

## service worker(离线应用)
* [参考文献1](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)