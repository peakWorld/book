# 缓存
* 好处
  * 缓解服务器压力
  * 提升性能
  * 减少带宽消耗
* 缓存驱逐: 由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除.

## 缓存种类
* 浏览器缓存
  * HTTP缓存, 浏览器根据和服务端约定的一套规则来进行缓存工作。
* 代理服务器缓存
  * 与浏览器缓存性质类似, 但面向群体更广、规模更大。为大量用户提供服务,同一副本会被重用多次, 能有效减少响应时间和带宽。
* CDN缓存
  * 发送web请求, CDN会帮忙计算从那获取内容的路径短且快。经常访问的内容会放在CDN中。
* 数据库缓存
  * 响应结果直接存放在数据库中.

## 缓存位置
* 查找浏览器缓存时会按顺序查找: Service Worker-->Memory Cache-->Disk Cache-->Push Cache。

### Memory Cache
* 内存中的缓存, 最先被读取。但是渲染进程关闭(关闭Tab页), 缓存会被释放。
* 内存有限, 缓存在内存中的资源必须 占用小。base64、小体积的css、js文件等。

### Service Worker
* 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。
* 生命周期分为install、active、working; 一旦被install, 只会在active、working中切换

### Disk Cache
* 存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
* 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。

### Push Cache 推送缓存 ???
* 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。
* 只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

## 缓存策略

### 强缓存
* 直接读取浏览器缓存, 不发送请求。state code 为200

#### Expires 
* 服务器时间(GMT格式), 超过时间缓存失效
* 如果浏览器和服务器时间不一致、修改浏览器时间, 会导致缓存失效

#### Cache-control
* 优先级高于Expires
* 可以将多个指令配合起来一起使用, 达到多个目的
* no-store 没有缓存
  * 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次客户端发起的请求都会下载完整的响应内容。
* no-cache 缓存但重新验证
  * 不询问浏览器缓存, 直接向服务器询问缓存是否过期。
  * 每次发出请求到服务器（该请求会带有与本地缓存相关的验证字段）, 服务器端会验证请求中所描述的缓存是否过期; 若未过期（实际返回304）, 才使用本地缓存副本。
* private\public 私有和公共缓存
  * public 表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。
  * private 表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
* max-age=<seconds> 过期
  * 表示资源能够被缓存的最大时间。
  * max-age是距离请求发起的时间的秒数
* s-maxage=<seconds> 代理服务器中过期时间
  * 只对public缓存有效

### 协商缓存
* 缓存过期, 需要发起请求验证资源是否有更新。
```
  获取缓存 --> 没过期 --> 读取缓存 200
          --> 过期  --> 询问服务器 --> 读取浏览器缓存   304
                                 --> 加载新数据 200
```
* Last-Modified
  * 响应头, 本地文件最后修改日期
  * 弱校验器, 因为只能精确到1秒
* If-Modified-Since
  * 请求头, 为Last-Modified的值
  * 如果本地缓存被打开过(即使内容未修改),也会造成Last-Modified被修改, 导致服务端无法命中缓存而返回相同资源
* Etag
  * 响应头 文件指纹
  * 强校验器
* If-None-Match
  * 请求头, 为ETag的值
  * 服务端判断资源ETag是否改变, 有变动的话就返回新的资源

### 启发式的算法
* 如果浏览器什么缓存策略都没设置, 通常会取响应头中的Date减去Last-Modified值的10%作为缓存时间.

## 实际场景应用

### 频繁、定期变动的资源
* 首先使用Cache-Control: no-cache使浏览器每次都请求服务器, 然后配合ETag或者Last-Modified来验证资源是否有效。

### 长期不更新的资源
* revving技术: 在URL后面（通常是文件名后面）加上版本号, 加上版本号后的资源就被视作一个完全新的独立的资源, 同时设置一年甚至更长的缓存过期时长。
  * 弊端，所有引用这个资源的地方都需要更新链接; 使用自动化构建工具完成。
