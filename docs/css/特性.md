## 盒模型
* 标准模型(box-sizing:content-box) content
* ie模型(box-sizing:border-box) content + padding + border
```html
  <div>
    a<em>b<em>c<br />
    <!-- e<em>f<em>g<br /> -->
  </div>
  <!-- inline box(内联盒子): 1. a、c 匿名内联盒子;  2. em等标签 内联盒子 -->
  <!-- line box(行盒子): 1. 由多个内联盒子组成 2. 行盒子高度 内部最高的inline box的高度 -->
  <!-- containing box: div区域, 由多个行盒子组成 -->
```

## 浮动
* https://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/
* 浮动元素
```ts
  // 没有脱离文档流, 内容不会重叠
  // 与inline-block表现形式类似; 但是具有方向性, 且导致高度塌陷(破坏内联盒子)
```
* 清除浮动
```html
  <!-- 方法一. 当作最后一个子标签放到父标签那儿 -->
  <div style="clear:both;"></div>
  <!-- 方法二. 不适用于有超出范围的展示(比如: 有margin负值定位、负的绝对定位) -->
  <style>
    .fix{overflow:hidden; zoom:1;}
  </style>
  <!-- 方法三. 普适 -->
  <style>
    .fix{zoom:1;}
    .fix:after{display:block; content:'clear'; clear:both; line-height:0; visibility:hidden;}
  </style>
```

## 获取dom元素尺寸
* 内联样式 `dom.style.width`
* 实时样式 `dom.currentStyle.width || window.getComputeStyle(dom).width`
* 相对于页面左上角(视口) `dom.getBoundingClientRect().width`

## offset属性详解
* offsetParent  // 最近一个定位的父元素,默认是body
* offsetHeight  // height + padding + border ;如果滑动框存在,还要加上横向滑动框高度
* offsetWidth   // width + padding + border ;如果滑动框存在,还要加上纵向滑动框宽度
* offsetTop/offsetLeft // 元素border的边框(外边线) 到 offsetParent的边框(内边线)的 高/宽