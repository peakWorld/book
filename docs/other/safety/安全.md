原理、漏洞(危害)、案例、解决方案、场景

# 数据校验
 * 服务端必做(安全), 前端可做(体验)。
 * 是否满足数据类型、长度、数据范围、字符集合
 * 抽离公共方法, 统一校验方式 保持校验的一致性
手机号校验, 前端校验反馈及时、减少错误请求, 服务端校验 保证数据的正确性。

# 身份验证
 * 避免在URL中传递会话标识。
 * 注册时 用户名是合法字符和长度、密码禁止使用弱口令(长度大于8位且有大小写数字字符)
 * 登录时 要有验证码机制, 区分正常人和机器的操作, 防止暴力破解、批量化操作。 不仅仅在登录时, 在任何可机械化操作的地方都应该加上验证机制。
 * 登录失败 错误提示不展示详情(用户名不存在、密码错误), 防止猜解用户名

# 登录态隔离
 * 在应用程序中嵌入多个iframe，每个iframe都可以加载不同的网站。(同源策略限制)
 * 不同网站的登录信息设置不同的cookie

# 传输安全
 * 避免使用明文传输。(登录密码和银行卡信息等信息应该加密)
 注: 攻击者仍可以通过破解 JavaScript 代码或使用中间人攻击等方式获取用户的密码。建议采用 HTTPS 协议来传输数据，并在后端服务器上再次对密码进行验证和加密
 * 推荐使用POST和服务端进行交互(GET)

# 数据保护/脱敏
 * 不要明文保存敏感信息(LocalStorage)
 * 涉及隐私的敏感信息必须脱敏后显示给用户(姓名、QQ号、身份证号、银行卡号、邮箱、手机号、营业执照号、地址)
	注:可能会被嗅探收集、批量爬取，泄漏业务核心数据
 * 脱敏标准
 	* 鉴权信息（如口令、密保答案、生理标识等）不允许展示
 	* 身份证只显示第一位和最后一位字符，如3****************1。
 	* 移动电话号码隐藏中间6位字符，如134******48。
 	* 工作地址/家庭地址最多显示到"区"一级。
 	* 银行卡号仅显示最后4位字符，如************8639

# 文件安全
 * 上传、下载文件 要确认用户权限
 	* 避免涉密文件下载
 	*  避免跨权限上传、下载文件
 * 使用白名单对文件后缀进行校验/检测MIME头和文件头是否与文件后缀匹配/对保存的文件名强制随机化命名
 	注: 任意类型文件可上传存储在服务器(危险的木马、病毒会存储在服务器)

# 逻辑漏洞
 * 验证码爆破漏洞。
 验证码验证过一次无论成功或者失败，都应当在后台清空失效这个验证码。以防止攻击者使用一个正确验证码可以成功发起无数个请求。
 * 接口返回数据做空判断。
 例如空数据, 服务端返回的是null，而不是undefined、[]等。
 * Url规范
 对于URL中的参数必须进行合法性校验 / URL参数最简化，避免不必要的参数(不要通过URL参数传递)
 * 框架
 Vue(禁用 v-html 属性) / React(禁用 danerouslySetInnerHTML); 尽量避免直接进行原生DOM操作

# 页面重定向
 某些业务场景（例如登录跳转、导航前进后退）将接受不信任的用户输入，并返回一个302响应或者URL重定向; 攻击者通过操控输入的URL，可以欺骗用户跳转到不安全的页面，造成钓鱼攻击。
 * 尽量避免这种提供URL跳转、重定向的功能。
 * 尽量不要根据用户输入的URL参数拼接，进行跳转、重定向。
 * 后台配置允许跳转的目录和信任的域名列表，仅允许在白名单里跳转。
 * 如果无法限制用户输入，建议提供中间页面明确告知用户将离开本站。

# Xss跨站脚本
 ## 反射型
 > 用户打开携带恶意脚本的Url链接, 在用户打开页面的同时，浏览器会执行页面中嵌入的恶意脚本。
 [xss-reflective.html](/download/attachments/2522850405/xss-reflective.html?version=1&modificationDate=1681815347973&api=v2)
 ## 存储型
 > 分为两步: 上传恶意代码，比如评论区、留言板等等；打开带有恶意代码的网页。
 ## DOM型
 > 在输入时插入一段恶意脚本，最终展示时会执行恶意脚本。
利用了浏览器对于从服务器所获取的内容的信任; 来自不同渠道的恶意代码最终在前端页面中执行了。 
对数据来源、代码内容进行限制。
[xss-dom.html](/download/attachments/2522850405/xss-dom.html?version=1&modificationDate=1681815317976&api=v2)


 ## 威胁
 > 盗取用户cookie。
 通过 document.cookie 获取 Cookie，如果 Cookie 中包含登录信息，恶意脚本还会拿着 Cookie 伪造登录状态；
 > 按键记录和钓鱼.
 记录用户在浏览器的大部分操作，即使网页中不存在输入框，也会通过修改 DOM 进行伪造；
 > 让官方网站出现钓鱼页面。
 利用存储型 XSS 将包含广告的恶意代码植入到网页，这样所有访问者都能看到广告
 > 蠕虫攻击
 > 结合浏览器及其插件漏洞，下载病毒木马到浏览者的计算机上执行。

 ## 防护场景
 > 将GET参数值按原值输出到页面中（包括HTTP头、HTML标签、Javascript、CSS等处），必须做反射XSS防护。
 > 将用户提交的文本内容存储在后台并在前端展示的场景。如用户注册（姓名、产品名、签名、个人简介）、评论、反馈、UGC发表，文件名，必须做存储型XSS的防护。
 > 若涉及URL目的跳转的逻辑（(例如location.replace、location.href等），或者涉及使用 innerHTML、document.write、eval 等敏感函数，必须做DOM型XSS防护。
 > 返回 JSON 的接口务必将 Content-Type 响应头设置为application/json 或 text/plain。
 > 涉及对页面内容进行多次编码的处理注意避免由于反编码等操作而导致的mXSS，即将原本无害编码内容又反编码为有害内容而导致的XSS。

 ## 措施
 > 限制用户合法输入、对用户的输入和输出进行编码和转义、使用安全的编程语言和框架, 最大限度避免恶意脚本内容传入
 > 使用安全防护策略（CSP）

# 点击劫持
通过欺骗用户单击看似无害的页面元素来执行恶意操作的网络攻击。
 * 案例
 假设正在使用一个在线银行服务，并在处理一笔重要的转账交易。恶意攻击者可以针对该服务创建一个看似无害的页面，用来欺骗您单击某个链接或按钮。例如，攻击者可能会创建一个透明的iframe覆盖在银行服务的页面上，并将转账提交按钮置于其中。当您单击看似正常的提交按钮时，实际上是单击了隐藏在iframe中的恶意按钮，从而完成转账交易。
 * 防护
 	* 检测自己的网页是否为顶层页面,否则跳转 `Window !==top && (top.location.href=window.location.href)`
 	* 设置http头部X-Frame-Options选项

# CSRF
跨站请求伪造，是指挟持用户在当前已登录的Web应用程序上执行非本意的操作。
 * 检查Referer字段(检查HTTP请求的Referer字段是否属于本站域名，非本站域名的请求进行拒绝。)
 * 添加校验token(服务器生成一个伪随机数作为token发给用户。当客户端通过请求时，这个token也一并提交上去以供后台校验)
 * 合理使用框架的CSRF防护功能
 [csrf.html](/download/attachments/2522850405/csrf.html?version=1&modificationDate=1681815366963&api=v2)

# CSP
仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本.
 * 防护
 	* 在后端应用中添加 `header("Content-Security-Policy: default-src 'self');`
 	* 在前端页面中使用<meta>添加 `<meta http-equiv='Content-Security-Policy' content='default-src 'self'' />`
 * 白名单
 	* 梳理页面功能实现过程中需要加载的资源，包括JavaScript脚本、CSS样式、字体文件、表单、需要引用的子页面等。
 	* 梳理、划分如上提到的需要加载资源的来源域名，整理成一份需要信任的“白名单”。
[csp.html](/download/attachments/2522850405/csp.html?version=1&modificationDate=1681815379080&api=v2)

# 总结
一个完整的数据安全传输策略不仅强制使用 HTTPS 进行数据传输，也为所有的 cookie 标记 secure 标识，并且提供自动的重定向使得 HTTP 页面导向 HTTPS 版本。网站也可以使用 Strict-Transport-Security HTTP 标头确保连接它的浏览器只使用加密通道。